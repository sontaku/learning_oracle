--19.PLSQLTrigger.sql
/*
1.트리거(TRIGGER)
	- PLSQL 블록, 특정 이벤트가 발생할 경우 연관된 작업을 수행하도록 하는 객체

2.TRIGGER 구조
	-구성 
        실행 시점(TIMING)
        사건(EVENT)
        영향 TABLE/VIEW/TRIGGER..
        BODY

	-문법 -대괄호는 생략가능한 부분
		CREATE [OR REPLACE] TRIGGER TRIGGER명
		TIMING
			EVENT 1[ OR EVENT2 OR ...]
		ON 
			TABLE명 OR VIEW명 (이벤트 등록 TABLE명)
		[REFERENCING OLD OR NEW]
		[FOR EACH ROW]
			TRIGGER BODY
	
	- TIMING : TRIGGER가 실행되는 시점 지정, EVENT 발생 전 혹은 후 의미
        - BEFORE
        - AFTER

3.참고
	-OLD : SELECT 데이터, :OLD    -> (SELECT를 통해 가져온)이전의 값
	-NEW : 지정한 데이터, :NEW
*/

--TRIGGER 생성 변경 삭제 권한 부여
    /*
    1. 관리자 접속
    conn SYSTEM/manager
    
    2. 권한 부여
    생성 권한
    GRANT CREATE TRIGGER TO SCOTT;
    
    변경 권한
    GRANT ALTER ANY TRIGGER TO SCOTT;
    
    삭제 권한
    GRANT DROP ANY TRIGGER TO SCOTT;
    
    위의 3개 한 번에!
    GRANT CREATE TRIGGER, ALTER ANY TRIGGER, DROP ANY TRIGGER TO SCOTT;
    */

--1.입력 시간 제한 TRIGGER
DROP TABLE ORDER_TABLE;

CREATE TABLE ORDER_TABLE(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	ORD_DATE DATE
);

-- 트리거는 테이블 하나에만 할당되므로, 여러테이블에 적용할 수 없다.
DROP TABLE ORDER_TABLE2;

CREATE TABLE ORDER_TABLE2(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	ORD_DATE DATE
);


--구성
--RAISE_APPLICATION_ERROR( [에러코드], [에러메시지] )
--에러코드 : -20000 ~ -20999 사이의 코드 (-20100 허용시간 아님)

/*
- 오전 10~12시 저장되는 INSERT만 허용
    - 10:00 ~ 12:00
    - 24HH:MI
    - SYSDATE -> 가공(TO_CHAR(SYSDATE, 'HH24:MI'))
*/

DROP TRIGGER TIME_ORDER;

CREATE OR REPLACE TRIGGER TIME_ORDER
BEFORE INSERT
ON
    ORDER_TABLE
BEGIN
    IF(TO_CHAR(SYSDATE, 'HH24:MI')NOT BETWEEN '09:00' AND '12:00') THEN
        RAISE_APPLICATION_ERROR(-20100, '허용시간 아님');
    END IF;
END;
/

INSERT INTO ORDER_TABLE VALUES(1, 'C001', SYSDATE);
SELECT * FROM ORDER_TABLE;

--2.입력값 제한 TRIGGER
-- ORD_CODE 컬럼에 'C001' 데이터를 제외한 나머지는 입력 불가
-- INSERT에 새로운 데이터 값    :NEW.ORD_CODE
-- 조건식

DROP TRIGGER DATA_FILTER_ORDER;

CREATE OR REPLACE TRIGGER DATA_FILTER_ORDER
BEFORE INSERT
ON ORDER_TABLE
FOR EACH ROW
BEGIN
    IF(:NEW.ORD_CODE) NOT IN ('C001') THEN
        RAISE_APPLICATION_ERROR(-20300, '무효한 제품 코드');
    END IF;
END;
/

--삽입 성공
INSERT INTO ORDER_TABLE VALUES(1, 'C001', SYSDATE);
INSERT INTO ORDER_TABLE VALUES(2, 'C001', SYSDATE);

SELECT  * FROM ORDER_TABLE;

--삽입 실패
INSERT INTO ORDER_TABLE VALUES(1, 'C002', SYSDATE);
SELECT * FROM ORDER_TABLE;


--3.BACKUP TABLE 관리 TRIGGER
--원본 TABLE : ORDER_TABLE
--백업 TABLE : BACKUP_ORDER
DROP TABLE ORDER_TABLE;

CREATE TABLE ORDER_TABLE(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
    
    --값이 들어갈 때의 시간
	ORD_DATE DATE
);

DROP TABLE BACKUP_ORDER;

CREATE TABLE BACKUP_ORDER(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
    
    -- 원본테이블에서 삭제되고 난 다음의 시점
	ORD_DATE DATE
);
-- 업데이트 했을 때 변화에 대한 부분을 저장할 수 있도록 지정
DROP TRIGGER BACKUP_TRIGGER;

CREATE OR REPLACE TRIGGER BACKUP_TRIGGER
BEFORE UPDATE
ON
    ORDER_TABLE
FOR EACH ROW
BEGIN
    INSERT INTO BACKUP_ORDER VALUES (:OLD.NO, :OLD.ORD_CODE, :OLD.ORD_DATE);
END;
/

UPDATE ORDER_TABLE SET ORD_CODE = 'C003' WHERE NO = 1;

SELECT * FROM ORDER_TABLE;
SELECT * FROM BACKUP_ORDER;




--4.?기존 TABLE의 데이터 DELETE시 BACKUP TABLE에 데이터 저장
--원본 TABLE : ORDER_TABLE2
--백업 TABLE : BACKUP_ORDER2
DROP TABLE BACKUP_ORDER2;
DROP TABLE ORDER_TABLE2;

CREATE TABLE ORDER_TABLE2(
	NO NUMBER,
	ORD_CODE VARCHAR2(10)
);

--백업 TABLE에 추가된 컬럼 : 삭제 시점
CREATE TABLE BACKUP_ORDER2(
	NO NUMBER,
	ORD_CODE VARCHAR2(10),
	TIME DATE
);

DROP TRIGGER BACKUP_TRIGGER2;

CREATE OR REPLACE TRIGGER BACKUP_TRIGGER2
BEFORE DELETE
ON
    ORDER_TABLE2
FOR EACH ROW
BEGIN
    INSERT INTO BACKUP_ORDER2 VALUES (:OLD.NO, :OLD.ORD_CODE, SYSDATE);
END;
/

INSERT INTO ORDER_TABLE2 VALUES(1, 'C001');
SELECT * FROM ORDER_TABLE2;
SELECT * FROM BACKUP_ORDER2;
DELETE ORDER_TABLE2 WHERE NO = 1;
SELECT * FROM ORDER_TABLE2;
SELECT * FROM BACKUP_ORDER2;



-- TIME_TABLE 에 글 작성시,
-- 시간의 분이 홀수 면 TIME_TABLE1
-- 시간의 분이 짝수 면 TIME_TABLE2에 저장되는 트리거
DROP TABLE TIME_TABLE;
CREATE TABLE TIME_TABLE(
	NO NUMBER,
	TEXT VARCHAR2(10),
    WRITE_TIME DATE
);

DROP TABLE TIME_TABLE2;
CREATE TABLE TIME_TABLE2(
	NO NUMBER,
	TEXT VARCHAR2(10),
    WRITE_TIME DATE
);

DROP TABLE TIME_TABLE3;
CREATE TABLE TIME_TABLE3(
	NO NUMBER,
	TEXT VARCHAR2(10),
    WRITE_TIME DATE
);

DROP TRIGGER BACKUP_TRIGGER2;

CREATE OR REPLACE TRIGGER BACKUP_TRIGGER2
BEFORE INSERT
ON
    TIME_TABLE
FOR EACH ROW
BEGIN
        IF(SUBSTR(TO_CHAR(:NEW.WRITE_TIME, 'MI'), -1)) THEN
    END IF;
    INSERT INTO BACKUP_ORDER2 VALUES (:OLD.NO, :OLD.ORD_CODE, SYSDATE);
END;
/
